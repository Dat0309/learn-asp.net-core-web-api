using TitanServices.DTO;
using TitanServices.Helper;
using TitanServices.Models;

namespace TitanServices.Services
{
    public class PostServices : IPostServices
    {

        private readonly PostContext _postContext;
        private readonly PostTupeContext _postTypeContext;

        public PostServices(PostContext postContext, PostTupeContext postTypeContext)
        {
            _postContext = postContext;
            _postTypeContext = postTypeContext;
        }

        public PostModel Create(PostModel post)
        {
            _postContext.Posts.Add(post);
            _postContext.SaveChanges();
            return post;
        }

        public IEnumerable<PostModel> createsMany()
        {
            var posts = new PostModel[]
             {
                new PostModel{
                    Title="YEAR-END PARTY!!! 2022",
                    ShortDesc="We at Titan recently celebrated the end of an eventful year with our YEAR END PARTY 2022! After a year of dedicated work, Titan have experie.Despite the challenges posed by the ongoing pandemic, economic instability, and other difficulties, we at Titan are grateful to have had your support. Together, we have managed to navigate through a difficult year. We also took this occasion to acknowledge and celebrate the outstanding contributions of our excellent employees during the past year. ",
                    FullDesc="Despite the challenges posed by the ongoing pandemic, economic instability, and other difficulties, we at Titan are grateful to have had your support. Together, we have managed to navigate through a difficult year. We also took this occasion to acknowledge and celebrate the outstanding contributions of our excellent employees during the past year.\r\n\r\nTitan big family had moments of full play and experienced a very special and funny year-end party together in solidarity. All promise a new year with lots of luck for everyone.\r\n\r\nAs we look forward to 2023, we at Titan remain committed to making further efforts to improve and grow as a company. We would like to extend our sincere gratitude for your continued support of Titan.",
                    Author="Admin",
                    Image="https://www.titancorpvn.com/uploads/images/news/YEP_2022_Activity_122022_0.jpeg",
                    PostTypeID=_postTypeContext.PostTypes.Single(i => i.Title == "NEWS & EVENTS")._id,
                    Url="https://www.titancorpvn.com/news/YEP_2022_Activity_122022",
                    CreateAt=DateTime.Now,
                },
                new PostModel{
                    Title="WARM WINTER CHARITY 2022",
                    ShortDesc="Titan organized a charity event named “Warm Winter” that gave away 288 packages of gift including uniforms, cold weather clothing, and schoo…",
                    FullDesc="Residing in a tropical country, we sometimes take for granted the life-saving necessities of staying warm. The truth is that there are areas within Vietnam where residents, especially underprivileged children, are affected by cold and extreme weather events. Acknowledging the harsh conditions faced by children living in remote and mountainous areas, Titan organized a charity event named “Warm Winter” that gave away 288 packages of gift including uniforms, cold weather clothing, and school stationary sets to the students at Da Nhinh Elementary School in Dam Rong, Lam Dong in October 2022. Our donation before the wintertime was more than just making the little kids comfortable. Titan members and the Company itself wanted to give the gift of hope that delighted the kids and inspired them to continue their education.",
                    Author="Admin",
                    Image="https://www.titancorpvn.com/uploads/images/news/Warm_Winter_Charity_2022_0.jpeg",
                    PostTypeID=_postTypeContext.PostTypes.Single(i => i.Title == "NEWS & EVENTS")._id,
                    Url="https://www.titancorpvn.com/news/Warm_Winter_Charity_2022",
                    CreateAt=DateTime.Now,
                },
                new PostModel{
                    Title="2020 TAX COMPLIANCE AWARDS",
                    ShortDesc="Titan Technology Corporation won the “2020 Tax Compliance Excellence Award” and the “2020 Taxation Responsibility Fulfillment Excellence Awa… ...",
                    FullDesc="Acknowledging that our taxes meaningfully fund essential public services for the country and represent an investment in raising the Vietnamese people's living standards, Titan has always actively contributed to government's revenues from taxation. For our accountable behavior, Titan Technology Corporation won the “2020 Tax Compliance Excellence Award” given by the Ho Chi Minh City Tax Department and the “2020 Taxation Responsibility Fulfillment Excellence Award” given by the People's Committee of Tan Binh District in April 2022. The awards were bestowed upon 69 out of 41,623 enterprises operating in Tan Binh District.",
                    Author="Admin",
                    Image="https://www.titancorpvn.com/uploads/images/news/20220607_2020_Tax_Compliance_Awards_0.jpeg",
                    PostTypeID=_postTypeContext.PostTypes.Single(i => i.Title == "NEWS & EVENTS")._id,
                    Url="https://www.titancorpvn.com/news/20220607_2020_Tax_Compliance_Awards",
                    CreateAt=DateTime.Now,
                },

                new PostModel{
                Title="5 TECH TRENDS IN HEALTHCARE AND MEDICAL APP DEVELOPMENT",
                ShortDesc="There are many medical apps on the market; every day there are more and more healthcare startups. If you decide to create a medical app, you need to think outside the box and you need to....",
                FullDesc="\r\nThere are many medical apps on the market; every day there are more and more healthcare startups. If you decide to create a medical app, you need to think outside the box and you need to create something new and extremely innovative that will combine all the best technologies in one app.\r\n\r\nNevertheless, what makes the healthcare application unique? Is it the UI that is easy to use? Auto-fill structure? “Time to take your pills” notifications? Home delivery from pharmacy options? Or maybe all mentioned above and more? In this article, let’s take a look at technological trends of healthcare and medical app development in the coming year.\r\n\r\n1. Mobile Health.\r\n\r\nWhat is it? According to the World Health Organization, mHealth (mobile health) is medical and public health practice supported by mobile devices, such as mobile phones, patient monitoring devices, personal digital assistants (PDAs), and other wireless devices. mHealth involves the use and capitalization on a mobile phone’s core utility of voice and short messaging service (SMS) as well as more complex functionalities and applications including general packet radio service (GPRS), third and fourth generation mobile telecommunications (3G and 4G systems), a global positioning system (GPS), and Bluetooth technology.\r\n\r\nThe future healthcare trends in 2021 are directly related to mHealth. Such mHealth applications provide 24-hour online chat platforms and medical video consultation apps. In addition to creating the above-mentioned online support network, they also allow requesting professional doctors at home based on patients’ symptoms.\r\n\r\n2. Machine Learning and Artificial Intelligence.\r\n\r\nWe know that future healthcare trends depend on machine learning and deep learning. AI is also a technology that takes healthcare trends to a new level. When the world faced a pandemic, artificial intelligence helped us. For example, scientists were using AI algorithms to discover the Covid-19 vaccine. In the next few years, we will easily manage such epidemics through complete control and artificial strategies. The use of AI and ML in healthcare has exceeded our expectations.\r\n\r\nMachine Learning in healthcare can detect diseases more accurately at an earlier stage, thereby helping to reduce the number of readmissions in hospitals. This technology has also gone a long way in discovering and developing new drugs with great potential to help patients with complex diseases.\r\n\r\n3. Digital Pharmacy.\r\n\r\nIt’s the fusion of the digital revolution and pharmacy. Buying healthcare products in online pharmacies and receiving them at your door is one of the facilities proposed by the technological revolution in the healthcare industry. This is a new and exciting concept in healthcare application development.\r\n\r\nDigital pharmacies not just provide you with your medicine, but also sort your pills by date and time, deliver them to you every month, including any other pharmacy items. Besides, digital pharmacies monitor and manage your refills together with your doctor so that you always have the medicines you need.\r\n\r\nBehind the scenes, they also work directly with your doctor and insurance company to save you time and trouble. And the most important that with digital pharmacies everything is in one place. They organize all your medicines, bills, and prescription details for easy use. One of the great solutions that can be an example in this area is PillPack by Amazon Pharmacy.\r\n\r\n4. IoMT in healthcare and medical apps development.\r\n\r\nWhat is it? The Internet of Medical Things (IoMT) envisions a network of medical equipment and people that use wireless communication to exchange medical data.\r\n\r\nVarious devices and mobile applications of the Internet of Medical Things (IoMT) play a vital role in tracking and preventing chronic diseases of many patients and their doctors. By combining the development of the Internet of Things with telemedicine and telemedicine technology, a new Internet of Medical Things (IoMT) has emerged. This method involves the use of many wearable devices, including ECG and EKG monitors. With modern full-cycle software product development services, many other common medical measurements can also be taken, such as skin temperature, glucose level, and blood pressure readings.\r\n\r\n5. Augmented, Virtual, and Mixed Reality.\r\n\r\nVR and AR in healthcare are important technologies that have great potential to improve the quality of telemedicine during the COVID-19 pandemic. From enhancing patient and provider access to helping medical students with program simulation education, this technology is turning science fiction into reality. These technologies can bring contemporary benefits to surgeons and medical students. VR can help doctors use extended reality solutions to train themselves.\r\n\r\nTo sum up, we can write only 14 letters, but they will include over 5 technological trends in healthcare app development in 2021: ML, AI, VR, AR, MR, IoMT.\r\n\r\n— 0o0 —\r\n\r\nAs one of leading software development outsourcing companies in Vietnam, Titan Technology always use cutting-edge technologies to deliver all the best outcomes to our partners in over the world along with providing above good environments for any developer will need to explore themselves in this market.\r\n\r\nIn case you just grew your interest in working with Titan Technology, we are opening for many positions that suit with all your potential.\r\nFor your own feeling about Titan, feel free to check our website and submit your CV to us if you already have interest to become a Titaner :\r\n\r\nGet inspired with Titan’s environment here: https://www.titancorpvn.com\r\nReach to our incredible Recruitment Team: recruitment@titancorpvn.com\r\nSource: By Romana Kuts",
                Author="Admin",
                Image="https://blog.titancorpvn.com/wp-content/uploads/2021/04/5-Tech-Trends-in-Healthcare-and-Medical-App-Development-01.jpg",
                PostTypeID=_postTypeContext.PostTypes.Single(i => i.Title == "BLOGS")._id,
                Url="https://blog.titancorpvn.com/5-tech-trends-in-healthcare-and-medical-app-development/",
                CreateAt=DateTime.Now,
                },
                 new PostModel{
                Title="A DEVELOPER’S TALE OF DEADLINES AND FANTASY TIME ESTIMATES",
                ShortDesc="You were asked to write a program, and during the discovery phase of the discussions, you were asked how long it was going to take",
                FullDesc="You were asked to write a program, and during the discovery phase of the discussions, you were asked how long it was going to take. The spotlight was on you and everyone turned to face you. On their faces you could see the real question they were asking… How long are you going to set us behind our actual target? Cause let’s face it, that is what they really want to know. How long do they have to wait before they can use and advertise that new feature to the market?\r\n\r\nYou start to feel the pressure that everyone is suddenly counting on you. Maybe you are the new developer on the team, the last thing you want to do is to let everyone down. Without any real research or details, you make a quick mental calculation and ballpark a time frame, based on what you know so far.\r\n\r\n“It could take me about 6 weeks, give or take”, you say, all the while hoping they note you said “could” to imply speculation and not a fixed possibility.\r\n\r\n“Okay! If you could bring that down to 4 weeks that would be fantastic yeah?” is what you hear.\r\n\r\nEveryone is excited. Your manager is brimming as they note the time frame down and base plans around that schedule. They are expecting a working program in 4 weeks. You look around at everyone making plans around that time estimate, and that’s when it sets in, a nagging uneasiness at the back of your mind; you didn’t factor all the things that could go wrong and will go wrong. A nagging thought starts to settle in, there is something you forgot to account for. Anyway, what’s done is done, you say to yourself. You decide you will do the best you can with the time you have and hope everything goes as close to the plan as possible. Let the journey begin.\r\n\r\n\r\nDuring week 1, you finally receive the design documentation and program specifications. As you read the specifications, you notice some additional bullet points that were not mentioned in the initial discussion. You confirm with your manager if this is real or enhancement requests after the initial release. To your worst expectation, it is real and part of the initial requirements. You should have known not everything was mentioned in the discovery phase. You compare what you thought you were building with what you shall be building with the new design specifications. Somewhere by the end of the week 2, you have managed to jot down a few options on what possible approaches you could take to tackle the problem. You have mentally weighed their observable pros and cons (yes, observable because sometimes appearances are deceiving) and are close to selecting a single approach. You scribble a quick flow chart and theorize a couple of tests that your program must pass and those it must fail, basically define the boundaries of your testing conditions.\r\n\r\nBy the beginning of week 3, you have a clear direction to follow, you are aware you have only 2 weeks left but you feel confident enough since your action plan is already set, all you must do is build the parts. And so, you begin. Everything is going well and midway to week 3, you have begun testing a few of the components you have already built as you integrate them into the main program. Sometime during the middle of the third week, at the start of the fourth day, a critical bug gets reported on a different project and it requires your immediate action. You question whether it is critical or just a slight exaggeration. You get confirmation from your manager confirming it is critical if you could get right on it. You really do not have time for this but oh well you must look at it. What is the worst that could happen you wonder?  Naturally, you take on the task and sideline your current project. Suddenly, your co-workers are signing off and to your shock, it’s already the end of the day. You spent the entire day working on the bug, and to your dismay it’s the end of the day, you haven’t fixed the bug nor made any progress on the project. You start to feel just a little nervous. Next day, you are still working on fixing the bug, this time more voraciously, you have to get this done because all this time is costing your current project. Luckily by the end of the day, you have a working bug fix. You aren’t too happy with it because you haven’t had time to thoroughly test it, but then again you are way off your schedule, it’s already midday.\r\n\r\n\r\nBy week 4, you can finally get back to your project. You start to get a feeling of urgency creeping up on you. This is the deadline week. You psych yourself up, if you focus on this and only this, you could pull it off by a hair. Just as you start working on the project, you get called into a sync meeting, everyone is giving updates and all other parties want updates so they can revise the time frame. You are shocked; you completely forgot about this meeting. That takes off another 40 minutes at least from your time. You can feel the need for an extension; however, you haven’t figured out how to ask for one without seeming like you are just asking for the sake. You quickly put together a few slides with your flow chart showing what you have done so far and what you need to do. If you are going to get an extension, you will need everyone invested in understanding why it is important you get that extension.\r\n\r\nDuring the meeting you discuss what you managed to get done, the problems you encountered and how you intend to fix them, for those you still haven’t worked on, you discuss the strategies you intend to take when implementing them. Finally, with all the cards on the table, you make a request for an additional couple of days to complete your part in the project. Your manager eyes you curiously, then says okay, you get your extra week. You remain levelheaded, but inside you jump in relief. You didn’t need a whole week, but with a whole extra week, you could actually do more thorough testing. As you work to complete the project, you make a mental note to next time, not give time estimates, or better yet, ask for time to think about how long you think it will take. However, deep down, you know you will be doing this fantasy time estimate all over again on the next project, because for some reason, that is just how it goes.\r\n\r\n1. So why is this all-just fantasy?\r\na. Software development is subjective to a lot of the roadblocks encountered in any creative process.\r\n\r\nI have come to realize that writing software is a lot more of a creative process than people realize. The programming languages we choose, frameworks, libraries etc. are all technical, but how we implement them, integrate them, or manipulate them to solve a problem is inherently a creative process at the mercy of the person tasked with solving the problem. It is the reason multiple solutions can exist for the same problem. Everyone can have the same tools, but the masterpiece each produces is different and subjective to their creative process.\r\n\r\nWe go through the same motions as any creative writing. We have times when the plan is clear and times when we stare at our editor not knowing what to start with or what to write next. We design how everything is connected and where they are connected and keep revising these decisions as requirements change. We consider each user individually and at the same time we consider the collective users and how we might meet their needs. We write a bunch of code one day, then delete all of it another day because it just doesn’t sit right. We wake up some days confident with what we have done so far and some days we second guess every decision we have made thus far. This goes on until we have a final product. It’s a whirlwind of ups and downs.\r\n\r\nTime estimates in a creative process are akin to a sort of fantasy time. We hope it will take X amount of time, but at the end of the day, we truly do not know, it is just a hope based on similar situations or experiences.\r\n\r\nb. There are no real one size fits all solution.\r\nThe assumption behind time estimates is that problems that appear similar and are of similar complexity should by extension take a similar amount of time to solve. If you really think about it, if it was the same problem, all one would need to do is plug the same solution. Similar is not the same. Therefore however “similar” problems appear, they are inherently not the same and therefore require modifications to make them work. The time associated with these modifications is not always known or constant as each problem is a new venture.\r\n\r\nc. You probably have a lot of tasks you are working on.\r\n\r\nIdeally, when you initially estimated the time it would take, you did not factor in external environments such as how the other projects you were working on would still need your attention.  When asked for your time estimate, you probably isolated that project from all the rest. What you really meant was “Without other commitments and in a perfectly isolated environment, it could take me X amount of time if all other factors are held constant”. By factors you meant, if program specifications do not change, if no additional requests are made and if you do not have to share your time with other projects.\r\n\r\nd. Changing program specifications midway does not affect time in any predictable fashion.\r\nThere is an assumption that removing specifications directly means the software can be completed in less time. While this might be true in certain scenarios, I have yet to discover this as truth. Ironically, what I have experienced is adding or removing specifications midway just affects time estimates in the same way; they no longer apply. It does not mean you will finish the project faster. All it means is you must revise your software and consider how this change will affect the work you have already done thus far. It also means you must consider what you would need to add or remove to meet the new program requirements.\r\n\r\ne. Things will go wrong and sometimes there is no quantifiable time taken to fix them.\r\nSometime during the process, some unforeseen problems may occur, and it is entirely possible, it could take days or weeks to figure out how to solve those problems. Problems may come from your computer, your chosen language, framework, dev environment, latest updates released by one of your dependencies, inability to integrate third-party tools properly etc. It could even come from the solution you chose to implement. Turns out, maybe the testing phase revealed it is not as efficient as initially estimated and is therefore not optimal and now you are back to the drawing board 9 days before the deadline. Factoring for potential errors is difficult as you cannot foretell what problems may occur and how long it will take to solve them.\r\n\r\nf. There is a lot of interdependence within the system.\r\nWhen collaborating to write software in a team, it is common to split the tasks between team members. Ideally, each of the tasks can be completed independently, however, in some cases, they could depend on each other. If one-part lags, it drags the dependent part with it. Typically, to curb this, it is ideal to simulate the input and write one’s section accordingly as you wait for the actual input. Sometimes, this approach works but, in some cases, it may be harder to do. For example, it can be difficult to simulate images that require subsequent image processing to remove defects or unwanted artifacts without having an idea what the defects could be. Therefore, a delay in completing the first part that supplies input to a second part, may delay the second part as well.\r\n\r\n\r\nIn a team, collaboration is at the heart of writing chunks of software. You may be struggling to fix something and subsequently affect your teammate’s ability to work on their part, because it relies on you finishing yours. Thereby not only affecting your time schedule but theirs too putting pressure on both of you. Therefore, having proper estimates that account for delays on your side, could help your teammates estimate how they are also affected and can adjust the schedule appropriately without allowing the stress to beat the deadline fall on them.\r\n\r\ng. You aren’t good at estimation.\r\nIt’s easy when others place the time estimate on you and sure you can blame them, but sometimes, even your own time estimations just aren’t good enough. You thought it would take an hour, it took 2 hours. You thought it would take 2 weeks, you were given 1 week, you missed the deadline and were given an extra week and you still missed the deadline. Therefore, your initial estimation was still wrong. What are we without idealistic human optimism? It is easy to think of oneself as being able to power through the mental drain writing software takes, however, often, mental drain comes coupled with physical drain and the time taken to rest and power up in between is often overlooked. Small things often add up to big things. Taking time to rest, brainstorm occasionally, are tasks that are difficult to accurately quantify but do matter and can take up quite some time. They may seem trivial when ballparking an overall time estimate, but they significantly affect the time taken to write software.\r\n\r\n2. So why do we still need real time estimates?\r\nIf time is all a fantasy, why do we still need and rely on it? As much as software development is a creative process, it’s aim is to have real-time use.\r\n\r\na. Your users have a real-time use for it.\r\nImagine if you sat down at a restaurant for lunch and planned to order the special. However, when you asked the waiter how long it would take, they told you they had no clue, it would be ready when it was ready. I am pretty sure you would order something else. How do you plan the rest of your day around a lunch that has an unknown time factor in it? I mean you could gamble and order it and best-case scenario you get your lunch in 15 to 30 minutes or find yourself hours later still waiting for lunch.\r\n\r\n\r\nNeed has a time factor to it. Something needed in the next 3 months does not apply if it arrives in 6 months. Therefore, you may have to plan what is feasible around your user’s needs. If you are organizing a marathon and need an app made to track runner’s location, pace, vitals, speed and direct them along the proper route, there is absolutely no use in getting the app long after the marathon is over. It no longer solves the problem. Giving a time estimate to how much time would be needed to create the app can give stakeholders proper time to plan around the deadline or even start the project earlier than intended to meet the user’s needs. In the marathon scenario, if it is too late to create an app to meet that marathon, maybe for the next marathon, the project can be started well before the marathon’s date with the time estimated.\r\n\r\nb. Deadlines can help one stay focused.\r\nI tend to procrastinate sometimes and when it comes to my side projects, they can suffer especially when my interest has faltered, or when I have become deeply obsessed with a different project, and there is no fixed deadline. Time estimates help me stay focused on a specific task for a certain amount of time. Even though I may procrastinate within the set time frame, at the back of my mind, I am aware there is a project that needs to be completed and I will carve out time to get it done.\r\n\r\nc. Time estimates do aid in overall planning.\r\nI don’t think people ask for time estimates because they enjoy putting people under pressure, if they do, you should probably reconsider your work environment. Time estimates help others plan their part of the project around a given time frame. A lot of software is integrated or built to work hand in hand. You can’t launch a product if part of the product is missing a vital area. Since the entire system is the sum of its parts, how long it will take is affected by the time estimates of each part. With near approximate time estimates, the project manager can decide which parts can be created in parallel, which parts can only start once a different section is complete and overall, how this affects when they can complete the project.\r\n\r\nWe tend to understand the reason for time estimates and why we sometimes fall short of how long we think something will take. So, the next step would be to re-evaluate how we estimate software design.\r\n\r\n3. So how can I get better at estimating?\r\nI still catch my breath when someone asks me, “How long will this take?” Why does this question cause me so much anxiety? Well, because at the back of my mind, I am aware of all the bits that go into time-estimates as well as all those we typically overlook. However, with time I have come up with a bunch of steps I take to break down how long I think a project will need. I haven’t nailed it down to the second, however, with time I have gotten better at giving better approximations on how long I think I will take on a project.\r\n\r\na. Give a rough estimate and ask for time to break down the problem and come back with a better estimate.\r\n\r\nNowadays, I give an initial rough estimation based on the mental gymnastics I can perform at that time; however, I also ask for some time to come up with a better time estimate outside of the meeting environment. Doing this often allows me to sit with the scope of the project, break it down into chunks and identify what I think each chunk will take. Once that is done, to each chunk I add various miscellaneous time estimates, “Exploratory time”, “Bug fix time” and “Pause time”. These are not industry terms just personal terms.\r\n\r\n“Exploratory time” is generally the time I estimate I will take to consider my options in determining how to implement that chunk. Great thing about writing software to solve problems is there can be multiple solutions to one problem. Ironically, this can also sometimes be a problem. Too many options can lead to analysis paralysis when trying to determine which approach one should use given their problem. Personally, when choosing options, I do take time to consider how each option could solve the problem, their flexibility, advantages, disadvantages, future maintainability, and general interdependence. I also consider, if I choose to change my approach later, what will be the cost to switch to a different solution and how difficult will that be? I have found that adding an exploratory time also allows me to research without feeling like I am costing the overall time, because I accounted for time to explore my options in depth.\r\n\r\n“Bug fix time”, is generally the time I estimate it will take me to find and fix bugs in a particular chunk. When writing software that is like something you have implemented previously, this time estimate might not be necessary, however, for newer programs, it might just be necessary. I find having this time is a safety net for when I get stuck on a bug that I am unsure how to solve. It isn’t easy to estimate how long it will take to fix a bug but estimating there will be no bugs at all is worse. When bugs do pop up, urgency and subsequently stress set in because you had not budgeted for time to fix bugs. This has happened to me in the past, and I hated it. However, expecting things to go wrong and having time set aside to solve them can leave you feeling calm and still on time in the grand scheme of things.\r\n\r\n“Pause time” is generally a nice way of saying break time. Time to step away from the software, take a break and refresh. Each chunk gets its own pause time because not all chunks are the same, thus their mental and physical drain can be different. The break I need after fighting with css may not be the same break I need after writing tests.\r\n\r\nGenerally, consider your habits when writing programs, how long did those small things you overlook take? Find a way to term them and add them to your general time estimates.\r\n\r\nb. Estimate sections you are familiar with differently from those you are unfamiliar with.\r\n\r\nFamiliar things are easier to estimate because we have done them 10, 100 or even 1000 times. We know the general flow and how long it takes us to work on them. However, even things that seem similar are not always entirely similar in every aspect. Nonetheless, even minor variations are easy to handle because they only deviate so slightly. Therefore, their estimates can be close enough to problems previously encountered.\r\n\r\nThings we are unfamiliar with are harder to estimate because we have never done them before. Maybe we have heard of them and know the general approach, but we have never actually sat down and implemented them. So how do we estimate something we have never done before? One approach would be to use estimates based on other’s experience. When we do not know how long something will take, we could either make a speculative guess, or rely on those with experience on the matter and ballpark our estimates based on theirs. It is not ideal, but it is better than magically producing a number. However, there are a lot of unknowns that come with using other people’s estimates on how long a task should take. For one, time estimates on known matters are subjective and can be influenced by experience. Someone who has designed and written hundreds of application code that queries databases may take only X amount of time to implement something similar when compared with someone who has never done it before. Knowledge in a certain domain also influences how long one takes to write code in that domain. We are all different.\r\n\r\nPersonally, when it comes to estimating the time, I will take to work on something I have never done before, I tend to take a senior’s time estimate then double it. By doubling it, I can have time to implement it twice in theory. Once to get it done, and I use the extra time to review my understanding of the task, setting myself up for the next time I may have to implement a similar task.\r\n\r\nc. Remember to take your personal habits into account.\r\nPeople are different and have different habits. How we tackle problems, how we brainstorm and eventually how we assess, and handle situations is also different. Some people prefer to tackle the same problem for hours on end then take breaks, while others prefer to concentrate for a couple of minutes with short breaks in between. Some would prefer to work on mentally tasking projects during the evening while others prefer working on such tasks in the morning hours of the day. Some people can’t work on an empty stomach while others can’t work on a full stomach. Nonetheless, whatever your preference is, consider how your habits affect your performance and take them into account when estimating. Will you need more breaks in between or not? Do you need to devote ample time to doing research or not?\r\n\r\nd. Keep your team informed, and if revisions are necessary, consult them.\r\n\r\nAll in all, whatever happens, always keep your team in the know. I do realize this is not a direct way of getting better at giving time estimates, but constantly communicating with your team about your efforts and where you are in the timeline can allow you and your team to revise the timeline and everyone that is affected is informed well ahead of time. Remember writing software and launching a product is a team effort, you may not think they are affected by revisions to your timeline, but they probably are.\r\n\r\ne. Lastly, learn from your own estimations.\r\nEvery time you work on something, note how long you thought it would take, and how long it took. Then compare how far off your estimation was. Were there outside factors that caused this value to deviate exceptionally, and if there were what were those factors. With time and learning from your own experience, you should get better at estimating.\r\n\r\nBy having close to accurate time estimates, you will realize you may finish projects earlier than expected if everything goes right. When things do go wrong, you still have some time to fix them without affecting the overall project deadline.\r\n\r\n— 0o0 —\r\n\r\nAs one of leading software development outsourcing companies in Vietnam, Titan Technology always use cutting-edge technologies to deliver all the best outcomes to our partners in over the world along with providing above good environments for any developer will need to explore themselves in this market.\r\n\r\nIn case you just grew your interest in working with Titan Technology, we are opening for many positions that suit with all your potential.\r\nFor your own feeling about Titan, feel free to check our website and submit your CV to us if you already have interest to become a Titaner :\r\n\r\nGet inspired with Titan’s environment here: https://www.titancorpvn.com\r\nReach to our incredible Recruitment Team: recruitment@titancorpvn.com\r\nSource: By Louiz Loet",
                Author="Admin",
                Image="https://blog.titancorpvn.com/wp-content/uploads/2021/04/A-developers-tale-of-deadlines-and-fantasy-time-estimates-01.jpg",
                PostTypeID=_postTypeContext.PostTypes.Single(i => i.Title == "BLOGS")._id,
                Url="https://blog.titancorpvn.com/a-developers-tale-of-deadlines-and-fantasy-time-estimates/",
                CreateAt=DateTime.Now,
                },
                  new PostModel{
                Title="A PRACTICAL GUIDE TO BETTER CODE REVIEWS",
                ShortDesc="A CODE REVIEW is a part of the development process in which a developer and their colleagues work together and look for bugs within some code",
                FullDesc="A CODE REVIEW is a part of the development process in which a developer and their colleagues work together and look for bugs within some code that may be ready for release. At such a moment, you can be either the code developer or one of the reviewers.\r\n\r\nOn one side of this process, you might not be sure of what you are looking for. On the other side, when submitting a code review, you might not know what to expect. This lack of empathy and wrong expectations between the two sides can trigger unfortunate situations and rush the process until it ends in an unpleasant experience for both sides.\r\n\r\nCode reviews can be a powerful means to achieve higher quality code, establish best practices, and to spread experience and knowledge. It also lets developers learn from their peers, practice mentorship, and engage in open dialog and discussion about what they build.\r\n\r\nHowever, when done wrong, code reviews can come to nothing or harm the interpersonal relationships of a team. Therefore, it is important to pay attention to the human aspects of code reviews. To be most successful, code reviews require a certain mindset and phrasing.\r\n\r\nHere’s how I have this organized:\r\n\r\nMy Code Review Experiences.\r\nGeneral Code Review Guidelines.\r\nCode Reviews as a developer.\r\nCode Reviews as a reviewer.\r\nWho Should Review?\r\nPositive Code Review Culture\r\nThe Subconscious Implications of a Code Review\r\n1. End-User Code Review (no process)\r\nWhen I started working as a developer, I remember having no code review process. In fact, the only review I got was a notification that some bit of code was not working correctly when a customer reported the issue. I learned very quickly that console.log did some nasty things with earlier versions of IE.\r\n\r\n2. Everyone Stare At Me (weekly target practice)\r\n\r\nFrom this, our team began an informal weekly process where we took some code and reviewed it while crammed into my boss’s office. What a painful process … having to explain design decisions on the spot in front of the entire development team; or even worse, trying to come up with intelligent questions about code in a language I had little familiarity with.\r\n\r\n3. Everyone Reviews (learning to accept criticism)\r\nThe next team I worked with had a review process that was embedded into the commit and push toward the production process. Everyone on the team was included in the process, by default. The tooling in Gerrit actually made the process much simpler and quite intuitive; in fact, we were able to get a group put into Gerrit that allowed us to simplify the process of adding people as reviewers.\r\n\r\nThe first few times my code was pushed, the code reviews were painful (not having a clue what to expect) and I firmly believe I was learning almost as much about code reviews as I was generating code for the project itself.\r\n\r\n4. How Is One Individual So Good At This?\r\nWe had an exceptional reviewer on this team that not only came up with exceptional insights into the code, he managed this in a way that made it feel painless. Because of this interaction, I have taken the time to investigate how I can duplicate this type of effort (the painless part … the insights I know will come with time).\r\n\r\n5. Code Review Guidelines\r\n\r\nThese guidelines stem from what a code review should accomplish. It is impossible to lay out guidelines that can be applied to every situation. Keeping these goals in mind will help achieve “the spirit” of code reviews even when a situation comes about that these guidelines don’t cover.\r\n\r\nCode reviews should:\r\n\r\nVerify that the code is a correct and effective solution for the requirements at hand.\r\nEnsure that the code is maintainable.\r\nIncrease shared knowledge of the codebase.\r\nSharpen the skill of the team through regular feedback.\r\nNot be an onerous overhead on developer time.\r\n6. As a Developer\r\nFor you, as the developer (or “author”, “submitter”), it is important to have an open and humble mindset about the feedback you will receive.\r\n\r\nAnyone can do a code review, and everyone must receive a code review, no matter the seniority level. Receive any feedback gratefully as an opportunity to learn and to share knowledge. Look at any feedback as an open discussion rather than a defensive reaction.\r\n\r\nWe are human. And humans make mistakes. This is completely normal. As long as the software is written by people, it will contain mistakes.\r\n\r\nThis does not mean that you should write code carelessly or stop writing tests. But this mindset will take away the fear of mistakes and create an atmosphere where making mistakes is accepted. This, in turn, is important for criticism during a code review to be accepted.\r\n\r\n7. Exchange of Experience\r\nDuring a code review, the developer and reviewer are exchanging best practices, experiences, tips, and tricks.\r\n\r\n\r\nThe developer and the reviewer are not only talking about the code they are exchanging best practices and experiences. Code reviews are a great means to establish and internalize good coding styles and best practices. And the exchange works in both directions. So consider code reviews as a valuable source of knowledge and an opportunity to learn.\r\n\r\n8. As a Reviewer\r\nLocating code to improve is a small part of a successful code review. Just as important is to communicate that feedback in a healthy way by showing empathy towards your colleagues.\r\n\r\nAs a reviewer, it is extremely important to pay attention to the specific language of the feedback. The phrasing is crucial for your feedback to be accepted.\r\n\r\nRight: “It’s hard for me to see what this code is doing.”\r\nWrong: “You are writing cryptic code.”\r\n\r\nAlways formulate the feedback from a personal point of view by expressing personal thoughts, feelings, and impressions. It is difficult for the code developer to argue against personal feelings since they are subjective.\r\n\r\nBefore submitting a comment, remember to put yourself in the other person’s shoes. It is too easy to be misunderstood, so review the comment, always staying respectful … speaking well to others is never a bad decision.\r\n\r\n9. Take the Developer Out of the Feedback\r\nTake the developer out of the feedback; only talk about the code that the developer is submitting for review. Criticism of the code is much harder to take personally because you are simply talking about the code, an objective thing, and not the developer. Again, this will improve the acceptance (as long as the developer understands that they are not their code).\r\n\r\n10. Non-Judgmental Collaboration\r\nThe whole team’s attitude and behavior should embrace non-judgmental collaboration, with the common goal of learning and sharing; regardless of experience level.\r\n\r\n\r\n11. Accept There Are Different Solutions\r\nKeep in mind that there are always different solutions to a problem. Most likely you have a favorite solution, but the developer’s solution may also be valid. Distinguish between common best practices and personal taste. Remember that skepticism may just reflect personal taste and not incorrect code.\r\n\r\n12. Remember Praise\r\nIt is totally acceptable to say: “Everything is good!”. No code changes is a valid outcome for a code review. Do not feel forced to find something wrong with the code.\r\n\r\nAnd last, but not least: do not forget to express appreciation if the code is good. Praising never hurts and may motivate the developer.\r\n\r\n13. Who Should Review?\r\nIt is my humble opinion that everyone on the team should be included on the code reviews. Simply from a learning perspective, every team member gets to see the release descriptions at a minimum. I got to the point when in a hurry where I would simply check the comments made across reviews throughout the day. By watching I was able to see what changes were occurring. When I had more time, I was an active reviewer trying to help make the codebase better, one comment at a time.\r\n\r\n14. Foster a Positive Code Review Culture\r\nCode reviews done by peers can put a strain on interpersonal team relationships. It is difficult to have work critiqued by peers. Therefore, in order for a peer code review to be successful, it’s extremely important that managers create a culture of collaboration and learning in the code review process.\r\n\r\nWhile it’s easy to see an identified defect as purely negative, each bug found is actually an opportunity for the team to improve code quality. Code reviews also allow junior team members to learn from senior leaders and for even the most experienced programmers to break bad habits.\r\n\r\nDefects found in a code review should not be used to evaluate team members. If review metrics become a basis for compensation or promotion, developers will become hostile toward the process and naturally focus on improving personal metrics rather than writing better overall code.\r\n\r\n15. Embrace the Subconscious Implications of a Code Review\r\nThe knowledge that someone else will be examining their work naturally drives people to produce a better product. This “Ego Effect” naturally incentivizes developers to write cleaner code because their peers will certainly see it. If your code is going to be reviewed, that is quite simply an incentive to double-check your work.\r\n\r\n16. Conclusions\r\nCode reviews are a powerful means to achieve higher quality code, establish best practices, and spread experience and knowledge. It also lets developers learn from their peers, practice mentorship, and engage in open dialog and discussion about what they build.\r\n\r\nTo be most successful, code reviews require a certain mindset and phrasing. Thus, it is supremely important to pay attention to the human aspects of a code review.\r\n\r\n— 0o0 —\r\n\r\nAs one of leading software development outsourcing companies in Vietnam, Titan Technology always use cutting-edge technologies to deliver all the best outcomes to our partners in over the world along with providing above good environments for any developer will need to explore themselves in this market.\r\n\r\nIn case you just grew your interest in working with Titan Technology, we are opening for many positions that suit with all your potential.\r\nFor your own feeling about Titan, feel free to check our website and submit your CV to us if you already have interest to become a Titaner :\r\n\r\nGet inspired with Titan’s environment here: https://www.titancorpvn.com\r\nReach to our incredible Recruitment Team: recruitment@titancorpvn.com\r\nSource: By Bob Fornal",
                Author="Admin",
                Image="https://blog.titancorpvn.com/wp-content/uploads/2021/03/A-Practical-Guide-to-Better-Code-Reviews-01.jpg",
                PostTypeID=_postTypeContext.PostTypes.Single(i => i.Title == "BLOGS")._id,
                Url="https://blog.titancorpvn.com/a-practical-guide-to-better-code-reviews/",
                CreateAt=DateTime.Now,
                },
             };
            foreach (var post in posts)
            {
                _postContext.Posts.Add(post);
            }
            _postContext.SaveChanges();
            return posts;
        }

        public void Delete(string id)
        {
            var post = _postContext.Posts.Find(id);
            if(post != null)
            {
                _postContext.Posts.Remove(post);
                _postContext.SaveChanges();
            }
        }

        public IEnumerable<PostModel> GetAll()
        {
            if(_postContext.Posts == null)return Enumerable.Empty<PostModel>();
            return _postContext.Posts;
        }

        public PostModel GetById(string id)
        {
            return _postContext.Posts.Find(id);
        }

        public void Update(PostModel postParam)
        {
            var post = _postContext.Posts.Find(postParam._id);
            if (post != null)
                throw new AppException("Post not found");

            post = postParam;
            _postContext.Posts.Update(post);
            _postContext.SaveChanges();
        }
    }
}
